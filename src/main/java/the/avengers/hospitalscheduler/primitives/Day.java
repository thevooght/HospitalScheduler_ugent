/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package the.avengers.hospitalscheduler.primitives;

import java.time.DayOfWeek;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;

/**
 * A Day contains the time slots and the arrivals for that particular day.
 *
 * @author Tony Stark
 */
public class Day {

    public DayOfWeek day;
    /**
     * The arrivals variable stores the arrivals the day. This is generated by
     * the arrival factory.
     */
    public Arrival[] arrivals;

    /**
     * The time slots for a particular day, either 16 or 32 are available
     * depending on which day of the week it is.
     */
    public TimeSlot[] timeSlots;
    public TimeSlot[] overtimeSlots;

    public Day(DayOfWeek day) {
        // Only open for half a day on Thursday and Saturday (16 slots) else 32.
        int iSlots = (day.equals(DayOfWeek.THURSDAY) || day.equals(DayOfWeek.SATURDAY)) ? 16 : 32;
        TimeSlot[] slots = new TimeSlot[iSlots];

        for (int i = 0; i < slots.length; i++) {
            slots[i] = new TimeSlot();
            // System.out.println("Setting tStart of slot i=" + i + " max=" + slots.length + " slot[i] == null? " + (slots[i] == null));
            slots[i].tStart = this.calculateStartOfSlot(day, i, slots[i].duration);
        }
        this.timeSlots = slots;
        this.day = day;
    }

    private Instant calculateStartOfSlot(DayOfWeek day, int slotIndex, Duration duration) {
        // We pick an initial point in time, in this case we picked the 8th of April 2019
        // because it's a monday. If we need the start time of a Tuesday, then we just add 1 day to it.
        // Same logic for the hour & minute timestamp.
        Instant tStart = Instant
                .parse("2019-04-08T08:00:00.00Z")
                .plus(day.getValue() - 1, ChronoUnit.DAYS)
                .plus(duration.multipliedBy((long) slotIndex));

        // We need to "skip" the time occupied by the lunch break.
        // Add the lunchbreak time to all tStart's after the lunchbreak.
        if (tStart.atZone(ZoneOffset.UTC).getHour() >= 12) {
            tStart = tStart.plus(1, ChronoUnit.HOURS);
        }

        return tStart;
    }

    /**
     * The daily overtime can be calculated by calculating the difference
     * between the scan end time of the last patient on a particular day and the
     * session end time of the day.
     *
     * @return the amount of overtime of a day.
     */
    public Duration tOverTime() {
        TimeSlot lastTS = this.timeSlots[this.timeSlots.length - 1];

        // Copy all arrivals to a new array and sort based on tScanEnd().
        Arrival[] tmp = Arrays.copyOf(this.arrivals, this.arrivals.length);
        Arrays.sort(tmp, Arrival.compareByScanEnd());
        Arrival lastArrival = tmp[tmp.length - 1];

        Duration overTime = Duration.between(lastTS.tEnd(), lastArrival.tScanEnd());
        if (overTime.isNegative()) {
            return Duration.ZERO;
        } else {
            return overTime;
        }
    }

    public void addOverTimeSlotsFor(Arrival[] overtimers) {
        this.overtimeSlots = new TimeSlot[overtimers.length];

        TimeSlot previousSlot = this.timeSlots[this.timeSlots.length - 1];
        for (int i = 0; i < this.overtimeSlots.length; i++) {
            this.overtimeSlots[i] = new TimeSlot();
            TimeSlot slot = this.overtimeSlots[i];
            slot.tStart = previousSlot.tEnd().plus(slot.duration);
            overtimers[i].tTimeSlot = slot.tStart;
            slot.assignedTo = overtimers[i];
            previousSlot = slot;
        }
    }

    /**
     * Returns true if all required fields for arrivals and time slots were
     * properly set.
     */
    public boolean isCompleted() {
        if (this.arrivals == null) {
            return false;
        }

        for (Arrival a : this.arrivals) {
            if (!a.isCompleted()) {
                System.out.println(a + " was not deemed completed.");
                return false;
            }
        }

        return true;
    }

}
